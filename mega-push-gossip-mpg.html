
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      
        Mega Push Gossip - MPG - 
      
      Research by Courtney Robinson
    </title>
    <meta name="description" content="Describes Mega Push Gossip - MPG a push push pull, gossip pprotocol">
    <meta name="author" content="Courtney Robinson">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->


    <link href="/assets/themes/hooligan/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/hooligan/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">    
    <link rel="stylesheet" type="text/css" href="/assets/themes/hooligan/css-social-buttons/css/zocial.stripped.css">
    <link href="/assets/themes/hooligan/css/pygments.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/hooligan/css/darkstrap.css" rel="stylesheet" type="text/css" media="all">    
    <link href="/assets/themes/hooligan/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <link rel="alternate" type="application/rss+xml" title="" href="/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="" href="/atom.xml">
    <!-- fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>      


          <a class="brand" href="/">Research by Courtney Robinson</a>
          <a class="brand" href="http://github.com/zcourts/Tesseract" title="Development currently happens in a private repo but will be made public under a BSD license soon.">Github Project (Tesseract)</a>

          <div class="nav-collapse">
            <ul class="nav">
              
              
              


  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  



            </ul>
            <ul class="nav pull-right social visible-desktop">
              <li class="divider-vertical"></li>
              
                <li>
                  <a href="https://github.com/zcourts" class="zocial github icon" target="_blank">
                    <span class="hidden-desktop">Github</span>
                  </a>
                </li>
              
              
                <li>
                  <a href="https://plus.google.com/117586181712312669408" class="zocial googleplus icon" target="_blank">
                    <span class="hidden-desktop">Google+</span>
                  </a>
                </li>
                  
              
                <li>
                  <a href="https://twitter.com/zcourts" class="zocial twitter icon" target="_blank">
                  <span class="hidden-desktop">Twitter</span>
                  </a>
                </li>
                                        
              
                <li>
                  <a href="http://www.facebook.com/zcourts" class="zocial facebook icon" target="_blank">
                    <span class="hidden-desktop">Facebook</span>
                  </a>
                </li>
                         
              
                <li>
                  <a href="http://www.linkedin.com/in/zcourts" class="zocial linkedin icon" target="_blank">
                    <span class="hidden-desktop">LinkedIn</span>
                  </a>
                </li>
                                  
              
                <li>
                  <a href="http://feeds.feedburner.com/zcourts-research" class="zocial rss icon" target="_blank">
                    <span class="hidden-desktop">FeedBurner</span>
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        
<div class="page-header-wrapper">
	<div class="page-header">
  		<h1>Mega Push Gossip - MPG </h1>
  	</div>
</div>

<div class="row">
  <div class="span12">
    <h1>Abstract - Introduction</h1>

<p>There are lots of gossip algorithms out there. Most of them use a communication model that doesn&#39;t directly send messages to nodes in the cluster, instead, information is disseminated by spreading the message with a sub-set of the nodes that&#39;ll in turn spread the message to another sub-set until all nodes have gotten the message. Often it takes O(log(n)) hops for all nodes to be updated.</p>

<p>While this is perfectly reasonable and appropriate for the scenarios they were designed for, it is somewhat unnecessary in a distributed database scene. Typically a single cluster has machines in the thousands, not hundredsof thousands or millions, as evidenced by the usage of projects like Hadoop, where <a href="http://wiki.apache.org/hadoop/PoweredBy#Y">Yahoo!</a> with the largest known cluster is only at 4500 nodes.</p>

<p>Current &quot;distributed&quot; databases are not really distributed in the same sense that say, a mobile network&#39;s users are distributed. While their architecture tends to be designed to scale to millions or billions of nodes in a cluster, other practical limitations (usually network/hardware related) often prevent them getting anywhere near the theoretical limits of the architecture/algorithms.</p>

<h3>True cost of gossip</h3>

<p>Gossip algorithms are typically described in terms of the number of network hops required to get all nodes up to date. While some mention the total time it takes the focus is often on network hops. With MPG, the cost of gossip has to be calculated differently. MPG assumes TCP over UDP for transmission to help improve delivery reliability. </p>

<h3>The latency problem</h3>

<p>Firstly, let&#39;s define some terms that may be used to discuss the properties of one gossip protocol.
Let:</p>

<ol>
<li><code>b</code> be buffer size of a node, i.e. the number of messages it buffers</li>
<li><code>t</code> be a limited number of hops or time steps, i.e. how far down the hierarchy a message from a node is disseminated. If it starts at A in a cluster up to F, where does dissemination stop, B,C,D,..?</li>
<li><code>f</code> be the number of randomly select nodes a message is forwarded to each time, i.e. how many nodes it sends messages to</li>
<li><code>n</code> be the number of nodes in the cluster.</li>
<li><strong><code>R</code></strong> be the number of <em>r</em>ounds/hops required for all nodes to be updated</li>
</ol>

<p><img src="/assets/gossip-b-f-t.png" alt="Diagram of message dissemination from UCL" title="Diagram of message dissemination from UCL"></p>

<p>Some gossip algorithms are based on mathematical models of epidemics and how they spread. Two such models are called the &quot;infect and die&quot; and &quot;infect forever&quot; models.Bella Bollobás <a href="#bollobas2001random">(Bollobás, 2001)</a> (reviewed in <a href="#eugster2004epidemic">(Eugster, Guerraoui, Kermarrec &#38; Massoulié, 2004)</a>)has shown that in an &quot;infect and die&quot; or &quot;infect-forever&quot; model, the number of rounds <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default.js"></script><script type="math/tex">R</script> necessary to infect the entire system is</p>

<script type="math/tex; mode=display"> 
R = \frac{log(n)}{log(log(n)))} + O(1)
</script>

<p>This assumes the number of f targets for contamination is <script type="math/tex">log(n)</script>.</p>

<p>In these models, if a cluster has 100 nodes and communication of a message is required to spread a message would take</p>

<script type="math/tex; mode=display"> 
R = \frac{log(100)}{log(log(100)))} + O(1); R = 7.64
</script>

<p>To satisfy f, n would have to be 2, i.e. log(100) = 2 randomly selected nodes will have a message forwarded to them in each round. </p>

<p>In a distributed network, say a mobile network with millions of users, the model is fine and works really well in terms of scalability. In a distributed database however with thousands of nodes or even 100 thousands nodes, the priority is often latency AND the number of messages. Depending on what the gossip protocol is being used for, a message can be emitted at millisecond intervals with expected response times within milliseconds as well. Using the infect-forever or infect and die approach, we can model an estimated latency for dissemination.</p>

<p>This is a simple model that will assume the latency between each node in the cluster is a constant time <script type="math/tex">k</script>. <a href="#cardwell2000modeling">(Cardwell, Savage &#38; Anderson, 2000)</a> shows that in a real world scenario latency is more variable and is dominated by startup effects such as establishing a connection and slow start. They present an approach for modelling TCP latency which takes into account transfer-size, round trip time and packet loss rate. The model presented here however somewhat neglects the dynamic nature of latency and assume it to be constant because even with a constant (low or high), the cumulative latency involved in the infect and die approach is demonstrably higher. In other words just using a constant is enough to prove the point.</p>

<p>Secondly, we assume that each node that recieves a message immediately forwards it and hence that the time taken between receiving a message and forwarding it is negligible. In practice however, not all nodes will be able to forward a message as soon as it is received and this will added to the overall perceived latency of disemminating a message.</p>

<p>Let <script type="math/tex">R</script> be the number of rounds as defined above, <script type="math/tex">n</script> the number of nodes in the cluster, <script type="math/tex">k</script> the latency per round. To spread a message to <script type="math/tex">n</script> nodes, it takes <script type="math/tex">R</script> rounds. Each round incurs a latency of <script type="math/tex">k</script>. Hence the latency to disseminate a message is simply the cumulative of the lot <script type="math/tex">l</script>:</p>

<script type="math/tex; mode=display">
l = \sum\limits_{r = 1}^R k
</script>

<p>For a message which requires a response that can be modified as
<script type="math/tex; mode=display">
l = 2 \left( \sum\limits_{r = 1}^R k \right)
</script></p>

<p>Naturally, the value k can be determined <a href="#cardwell2000modeling">(Cardwell, Savage &#38; Anderson, 2000)</a> or other just latency prediction models. In real terms, this means that if there are 100 nodes in the cluster and a constant per round latency of 50 milliseconds, sum over k, from 1 to 7</p>

<script type="math/tex; mode=display">
l = \sum\limits_{r = 1}^{7} 50 \equiv 50 + 50 + 50 + 50 + 50 + 50 + 50 = 350ms, 2(350) =700ms
</script>

<p>i.e given those assumptions, 350ms for a single message and 700ms for a response.</p>

<h3>The number of messages problem</h3>

<p>Only the latency has been considered so far, the number of messages involved in a fanout approach however is also very important. In a distributed database, data is constantly being moved, added and queried, failures and other others are constantly adding to the number of messages that are having to be sent. <a href="#voulgaris2007hybrid">(Voulgaris &#38; Van Steen, 2007)</a> has shown that message overhead increases proportionally to the fanout. The network is a very finate and important resource. Ideally any communication protocol would not send any more messages than was absoluately necessary, in a data intensive system such as a database, a network can easily become saturated. The ideal protocol would help prevent staturation by sending a little meta-data as possible. In such a protocol, only failure or unexpected events should cause multiple messages to be sent for the same purpose.</p>

<h1>Mega Push Gossip - MPG</h1>

<p>Mega (as in Megaphone) Push Gossipe, MPG is a gossip algorithm favouring push epidemic but taking advantage of pull where appropriate.</p>

<h3>Differences and similarities to other gossip algorithms</h3>

<ul>
<li><p>MPG is a modification and merger of various gossip protocols. In reality Push Push Pull is a somewhat more suitable name because it ends up pushing at least twice as much information as it pulls. </p></li>
<li><p>The modification in the protocol is the use of O(1) communication for most operations, or all if possible. </p></li>
<li><p>Where latency or resource constraints demand it, a fanout approach is used to disamminate messages in O(log(n)) hops.</p></li>
<li><p>In a typical gossip protocol a single node has a partial view of the cluster, MPG changes this so that every node has a complete view, with direct access to routing information of each.</p></li>
</ul>

<h3>Complete view of the world</h3>

<p>Nodes in ogssip protocol usually only have a partial view of the cluster for one reason or another. This is typically due to these protocols not being designed specifically for environements with an abundance of memory and are expected to have millions of nodes. For a database however, this assumption is not applicable, servers typically have 10s of gigabytes of RAM dedicated to handling the database. Even without this much memory a complete view of the cluster with routing information for millions of nodes can easily be represented in megabytes of memory.</p>

<p>Assume there are 1 million nodes, n; Each node has a numeric ID, i which is represented by a unsigned 32-bit integer (<script type="math/tex">2^{32}-1</script>); Routing information (host and port) r, with an average size of 40 bytes. This is the minimal amount of information required to represent all the nodes, other meta data may be included as the system requires but with this information we can estimate that size required to represent all the nodes is:</p>

<script type="math/tex; mode=display">
S = n (r + i)
</script>

<p>i.e.
<script type="math/tex; mode=display">
1,000,000 (40 + 4) = 44,000,000 bytes; 41.96MB
</script></p>

<p>In practice a cluster is unlikely to reach 1 million nodes and for a modest 50K nodes :</p>

<script type="math/tex; mode=display">
50,000 (40 + 4) = 2,200,000 bytes; 2.098MB
</script>

<p>Only a tiny 2MB is needed. </p>

<h3>Independent and responsible nodes</h3>

<p>With MPG, contrary to other gossip protocols, every node is responsible for itself and letting others know of it&#39;s existence and state. Only when a node appears to have failed/disappeared will any other node attempt to contact it. Under normal operation each node must push their state and any information they wish to share to the rest of the world.</p>

<h2>Common/Defined operations</h2>

<p>Gossip protocols are used for a varient of reasons, below categorizes how MPG is used and defines some operations for each category. Each node has a numeric ID, this ID is assigned after</p>

<h3>Membership</h3>

<p>Each node normally has at least one seed node, unless it is the first node in the cluster. It communicates with the seed nodes to obtain information about the rest of the cluster. Membership operations include:</p>

<ul>
<li>world - Request the node being sent the message sends back it&#39;s view of the cluster</li>
<li>world-hash - Request the node being sent the message sends back a merkle tree representing it&#39;s view of the cluster</li>
<li>join - Tell a set of nodes that it is joining</li>
<li>leave - Gracefully leave the cluster by telling other nodes</li>
<li>ping - Pings a set of nodes to let them know it&#39;s still alive</li>
<li>pong - The response to a ping acknowledging a node&#39;s existence</li>
</ul>

<p><em>note</em> When a ping-pong interaction occurs, the node that sent the pong no longer needs to send a ping to the node it sent the pong to, both nodes can be confident that they can speak to each other using these two messages.</p>

<h3>Dissemination and Failure detection</h3>

<p>Using gossip to detect failed nodes. If a known node fails to ping or pong there may be a temporary issue or it may have crashed. </p>

<h3>Anti-entropy</h3>

<p>Repairing replicated data (compare replicas and reconcile differences)</p>

<h3>Aggregates</h3>

<p>Collect per node stats (load etc), combine to form system wide view</p>

<h3>Reputation</h3>

<p>Nodes gain a reputation by being more available and completing more of their tasks without failure. Does the reverse to lose it</p>

<ul>
<li><a href="http://www.info.ucl.ac.be/courses/SINF2345/2010-2011/slides/10-Gossip-lecture-hand.pdf">Université Catholique de louvain, UCL - Gossip lecture</a></li>
<li><a href="http://web.mit.edu/vdb/www/6.977/l-shah.pdf">Gossip Algorithms, MIT</a></li>
<li><a href="http://lex104.cs.unibo.it/pub/UBLCS/2004/2004-07.pdf">T-Man: Fast gossip-based construction of large-scale overlay topologies</a></li>
</ul>

<h2>References</h2>

<ol class="bibliography"><li><span id="bollobas2001random">Bollobás, B. (2001). <i>Random graphs</i> (Vol. 73). Cambridge university press.</span></li>
<li><span id="eugster2004epidemic">Eugster, P. T., Guerraoui, R., Kermarrec, A.-M., &#38; Massoulié, L. (2004). Epidemic information dissemination in distributed systems. <i>Computer</i>, <i>37</i>(5), 60–67.</span></li>
<li><span id="cardwell2000modeling">Cardwell, N., Savage, S., &#38; Anderson, T. (2000). Modeling TCP latency. In <i>INFOCOM 2000. Nineteenth Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings. IEEE</i> (Vol. 3, 1742–1751).</span></li>
<li><span id="voulgaris2007hybrid">Voulgaris, S., &#38; Van Steen, M. (2007). Hybrid dissemination: adding determinism to probabilistic multicasting in large-scale P2P systems. In <i>Proceedings of the ACM/IFIP/USENIX 2007 International Conference on Middleware</i> (389–409).</span></li></ol>

  </div>
</div>


      </div>

      <footer>
        <p>&copy; 2014 Courtney Robinson</a> <a href="/terminology.html"> Terminology used</a>
        </p>
      </footer>
    </div> <!-- /container -->

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="/assets/themes/hooligan/js/jquery.min.js"><\/script>')</script>
    <script src="/assets/themes/hooligan/bootstrap/js/bootstrap.min.js"></script>

    
  </body>
</html>

